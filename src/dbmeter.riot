<dbmeter>
  <table onclick={ reset }>
    <tbody>
      <tr each={ i in [
          { name: 'RMS', read: state.avg },
          { name: 'PEAK', read: state.peak }
        ]}>
        <th>{ i.name }</th>
        <td>
          <meter
            min={ props.default || -100 }
            low="-6"
            high="-1"
            max="10"
            value={ i.read.value }></meter>
        </td>
        <td class="read">
          <span class="max { (i.read.max > -1) ? `alert`: `` }">{ i.read.max.toFixed(2) }</span>
          <span class="scale">{ i.read.scale }</span>
        </td>
      </tr>
    </tbody>
  </table>
  <style>
    @keyframes info {
      50% {
        background-color: #fed8b1;
      }
    }
    td { 
      padding-left: 2px;
      text-align: left;
    }
    td > .max {
      width: 2rem;
      display: inline-block;
      text-align: right;
      padding-right: 2px;
    }
    td > .scale {
      font-weight: bold;
    }

    .blink {
      animation: info ease 0.4s 1;
      /* use 400 as timeout to remove class */
    }
    .alert {
      color: #fed8b1;
      background-color: #b89aa5;
    }
    :host table {
      margin-left: 1rem;
      cursor: pointer;
    }
    :host tr {
      font-size: 0.5rem;
    }
    :host td meter {
      width: 6rem;
    } 
  </style>
  <script>
    class MeterInfo {
      constructor(value, max, dflt) {
        this.value = this.max = MeterInfo.finite(value, dflt);
        this.max = Math.max(this.max, MeterInfo.finite(max, dflt));
        this.scale = 'dB';
      }
      reset() {
        this.max = this.value;
      }
      static finite(v, d) {
        return v !== null && isFinite(v) ? v : (d || -100);
      }
    };
    function uint2float32(byteBuffer) {
      return byteBuffer.reduce((float, byte, i) => {
        float[i] = (byte - 128) / 128.0;
        return float;
      }, new Float32Array(byteBuffer.length));
    };
    export default {
      state: {
        analyser: null,
        frame: null,
        avg: null,
        peak: null,
      },
      onBeforeMount(props, state) {
        state.avg  = new MeterInfo(null, null, props.default);
        state.peak = new MeterInfo(null, null, props.default);
        state.analyser = props.ctx.createAnalyser();
        state.analyser.fftSize = props.fftSize || 2048;

        props.in.connect(state.analyser);
        state.analyser.connect(props.out);
      },
      onMounted(props, state) {
        this.loop();
        this.root.addEventListener('dbmeter.reset', () => {
          this.reset();
        });
      },
      onUnMounted(props, state) {
        if (state.frame) {
          window.cancelAnimationFrame(state.frame);
        }
      },
      loop() {
        const { analyser } = this.state;
        ((timestamp) => {
          const byteBuffer = new Uint8Array(analyser.fftSize);
          analyser.getByteTimeDomainData(byteBuffer);

          const floatBuffer = uint2float32(byteBuffer);
          
          // Compute average power over the interval.
          const [ sumOfSquares, peakInstantaneousPower ] = floatBuffer
            .reduce(([ sum, peak ], buffer) => {
              const power = buffer ** 2;
              return [ sum += power, Math.max(power, peak) ];
            }, [ 0, 0 ]);
          const avg = 10 * Math.log10(sumOfSquares / floatBuffer.length);
          const peak = 10 * Math.log10(peakInstantaneousPower);

          this.update({
            avg: new MeterInfo(avg, this.state.avg.max),
            peak: new MeterInfo(peak, this.state.peak.max),
          });
          this.state.frame = window.requestAnimationFrame(this.loop.bind(this));
        })();
      },
      reset() {
        this.root.querySelectorAll('.max').forEach(r => {
          r.classList.add('blink');
          setTimeout(()=>r.classList.remove('blink'), 400);
        });
        this.state.avg.reset();
        this.state.peak.reset();
      }
    };
  </script>
</dbmeter>
