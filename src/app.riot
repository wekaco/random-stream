<app>
  <article>
    <stem
      each={ uri in props.stems }
      uri={ uri }
      ctx={ state.ctx }
      load={ onStemLoad }
      error={ onStemError }
      out={ state.master }
    ></stems>
  </article>
  <footer>
    <dbmeter
      ctx={ state.ctx }
      fftSize=2048
      in={ state.master }
      out={ state.ctx.destination } >
    </dbmeter>
      <control
        name="play"
        onclick={ play }
        disabled={ state.disabled  }>Play
      </control>
      <control
        name="pause"
        onclick={ pause }
        disabled={ state.disabled }>Stop
      </control>
    </footer>
    <style>
    </style>
  <script>
    import Control from './control.riot';
    import Dbmeter from './dbmeter.riot';
    import Stem from './stem.riot';
    import noop from './noop';

    const CTX_ERROR = 'ctx.error';

    export default {
      state: {
        current: new Set(),
        disabled: true,
        ctx: new (window.AudioContext || window.webkitAudioContext)(),
        buffer: null,
        master: null,
        stems: [],
      },
      components: {
        Control,
        Stem,
        Dbmeter,
      },
      onBeforeMount(props, state) {
        state.master = state.ctx.createGain();
      },
      onStemLoad(e) {
        const { id } = e.detail;
        const stem = this.root.querySelector(`#${id}`);
        stem.addEventListener('stem.play', () => this.state.current.add(stem), { once: true });
        this.update({ disabled: false });
      },
      onStemError(e) {},
      ctx(cb) {
        cb = cb || noop;
        const{ ctx } = this.state;
        // If closed already resume with reject promise
        // or else it is suspended and expected to resume
        if (ctx.state === 'running') {
          // Web/API/AudioContext.resume
          return cb(null, ctx);
        }
        ctx.resume()
          .then(()=>cb(null, ctx))
          .catch(cb);
      },
      play() {
        this.ctx((err, ctx) => {
          if (err) {
            this.root
              .dispatchEvent(new CustomEvent(CTX_ERROR, { detail: err }));
            return;
          }
          this.pause();
          this.root.querySelectorAll('stem')
            .forEach( s => s.dispatchEvent(
              new CustomEvent('stem.cue', { detail: 0 })
            ));

        });
      },
      pause() {
        for (let [ _, element ] of this.state.current.entries()) {
          element.dispatchEvent(new CustomEvent('stem.stop'));
        };
        this.state.current.clear();
      }
    };
  </script>
</app>
