<app>
  <article>
    <stem
      uri={ props.master }
      ctx={ state.ctx }
      load={ onStemLoad }
      error={ onStemError }
    ></stems>
  </article>
  <footer>
      <control
        name="play"
        onclick={ play }
        disabled={ state.disabled  }>Play
      </control>
      <control
        name="pause"
        onclick={ pause }
        disabled={ state.disabled }>Stop
      </control>
  </footer>
  <script>
    import Control from './control.riot';
    import Stem from './stem.riot';
    import noop from './noop';

    const CTX_ERROR = 'ctx.error';

    const bin = [];

    export default {
      state: {
        disabled: true,
        ctx: new (window.AudioContext || window.webkitAudioContext)(),
        buffer: null,
        master: null,
      },
      components: {
        Control,
        Stem,
      },
      onBeforeMount(props, state) {
      },
      onStemLoad(e) {
        const { uri, buffer } = e.detail;
        this.state.buffer = buffer;
        this.update({ disabled: false });
      },
      onStemError(e) {
      },
      onBeforeMount(props, state) {
      },
      ctx(cb) {
        cb = cb || noop;
        const{ ctx } = this.state;
        // If closed already resume with reject promise
        // or else it is suspended and expected to resume
        if (ctx.state === 'running') {
          // Web/API/AudioContext.resume
          return cb(null, ctx);
        }
        ctx.resume()
          .then(()=>cb(null, ctx))
          .catch(cb);
      },
      play() {
        this.ctx((err, ctx) => {
          if (err) {
            this.root
              .dispatchEvent(new CustomEvent(CTX_ERROR, { detail: err }));
            return;
          }
          if (this.state.master === null) {
            this.state.master = this.state.ctx.createGain();
            this.state.master.connect(this.state.ctx.destination);
          }

          const source = this.state.ctx.createBufferSource();
          source.loop = true;
          source.buffer = this.state.buffer;
          source.connect(this.state.master);
          source.start(0);

          this.pause();
          this.state.current = source;
        });
      },
      pause() {
        if (this.state.current) {
          const { current } = this.state;
          current.stop();
          //bin.push(current);
        }
        this.state.current = null;
      }
    };
  </script>
</app>
