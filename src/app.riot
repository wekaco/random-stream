<app>
  <article each={ uri in props.stems }>
    <stem
      uri={ uri }
      ctx={ state.ctx }
      load={ onStemLoad }
      error={ onStemError }
      out={ channel(uri) }></stems>
    <dbmeter 
      default=-42
      ctx={ state.ctx }
      fftSize=2048
      in={ channel(uri) }
      out={ state.master }></dbmeter>
  </article>
  <hr/>
  <footer>
    <dbmeter
      default=-42
      ctx={ state.ctx }
      fftSize=2048
      in={ state.master }
      out={ state.ctx.destination } >
    </dbmeter>
    <control
      name="play"
      onclick={ play }
      disabled={ state.disabled  }>Play
    </control>
    <control
      name="pause"
      onclick={ pause }
      disabled={ state.disabled }>Stop
    </control>
  </footer>
  <script>
    import Control from './control.riot';
    import Dbmeter from './dbmeter.riot';
    import Stem from './stem.riot';
    import noop from './noop';

    const CTX_ERROR = 'ctx.error';

    export default {
      state: {
        current: new Set(),
        channels: new Map(),
        disabled: true,
        ctx: new (window.AudioContext || window.webkitAudioContext)(),
        buffer: null,
        master: null,
        stems: [],
      },
      components: {
        Control,
        Stem,
        Dbmeter,
      },
      onBeforeMount(props, state) {
        state.master = state.ctx.createGain();
      },
      onStemLoad(e) {
        const { id } = e.detail;
        const stem = this.root.querySelector(`#${id}`);
        stem.addEventListener('stem.play', () => this.state.current.add(stem), { once: true });
        this.update({ disabled: false });
      },
      onStemError(e) {},
      ctx(cb) {
        cb = cb || noop;
        const{ ctx } = this.state;
        // If closed already resume with reject promise
        // or else it is suspended and expected to resume
        if (ctx.state === 'running') {
          // Web/API/AudioContext.resume
          return cb(null, ctx);
        }
        ctx.resume()
          .then(()=>cb(null, ctx))
          .catch(cb);
      },
      play() {
        this.ctx((err, ctx) => {
          if (err) {
            this.root
              .dispatchEvent(new CustomEvent(CTX_ERROR, { detail: err }));
            return;
          }
          this.pause();
          this.root.querySelectorAll('stem')
            .forEach( s => s.dispatchEvent(
              new CustomEvent('stem.cue', { detail: 0 })
            ));

        });
      },
      pause() {
        for (let [ _, element ] of this.state.current.entries()) {
          element.dispatchEvent(new CustomEvent('stem.stop'));
        };
        this.state.current.clear();
      },
      channel(uri) {
        if (!this.state.channels.has(uri)) {
          const gain = this.state.ctx.createGain();
          gain.connect(this.state.master);
          this.state.channels.set(uri, gain);
        }
        console.log('get', uri);
        return this.state.channels.get(uri);
      }
    };
  </script>
</app>
