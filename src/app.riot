<app>
  <article>
    <stem
      uri={ props.master }
      ctx={ state.ctx }
      load={ onStemLoad }
      error={ onStemError }
    ></stems>
  </article>
  <footer>
    <dbmeter
      ctx={ state.ctx }
      fftSize=2048
      in={ state.master }
      out={ state.ctx.destination } >
    </dbmeter>
      <control
        name="play"
        onclick={ play }
        disabled={ state.disabled  }>Play
      </control>
      <control
        name="pause"
        onclick={ pause }
        disabled={ state.disabled }>Stop
      </control>
    </footer>
    <style>
    </style>
  <script>
    import Control from './control.riot';
    import Dbmeter from './dbmeter.riot';
    import Stem from './stem.riot';
    import noop from './noop';

    const CTX_ERROR = 'ctx.error';

    export default {
      state: {
        disabled: true,
        ctx: new (window.AudioContext || window.webkitAudioContext)(),
        buffer: null,
        master: null
      },
      components: {
        Control,
        Stem,
        Dbmeter,
      },
      onBeforeMount(props, state) {
        state.master = state.ctx.createGain();
      },
      onStemLoad(e) {
        const { uri, buffer } = e.detail;
        this.state.buffer = buffer;
        this.update({ disabled: false });
      },
      onStemError(e) {},
      ctx(cb) {
        cb = cb || noop;
        const{ ctx } = this.state;
        // If closed already resume with reject promise
        // or else it is suspended and expected to resume
        if (ctx.state === 'running') {
          // Web/API/AudioContext.resume
          return cb(null, ctx);
        }
        ctx.resume()
          .then(()=>cb(null, ctx))
          .catch(cb);
      },
      play() {
        this.ctx((err, ctx) => {
          if (err) {
            this.root
              .dispatchEvent(new CustomEvent(CTX_ERROR, { detail: err }));
            return;
          }
          const source = this.state.ctx.createBufferSource();
          source.loop = true;
          source.buffer = this.state.buffer;
          source.connect(this.state.master);
          source.start(0);

          this.pause();
          this.state.current = source;
        });
      },
      pause() {
        if (this.state.current) {
          const { current } = this.state;
          current.stop();
        }
        this.state.current = null;
      }
    };
  </script>
</app>
